# 1 "lib\\ServoMotor\\src\\ServoMotor.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "lib\\ServoMotor\\src\\ServoMotor.cpp"
# 1 "lib\\ServoMotor\\src\\ServoMotor.h" 1



# 1 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\io.h" 1 3
# 99 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\io.h" 3
# 1 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\sfr_defs.h" 1 3
# 126 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\sfr_defs.h" 3
# 1 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\inttypes.h" 1 3
# 37 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\inttypes.h" 3
# 1 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\lib\\gcc\\avr\\5.4.0\\include\\stdint.h" 1 3 4
# 9 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\lib\\gcc\\avr\\5.4.0\\include\\stdint.h" 3 4
# 1 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\stdint.h" 1 3 4
# 125 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\stdint.h" 3 4

# 125 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\stdint.h" 3 4
typedef signed int int8_t __attribute__((__mode__(__QI__)));
typedef unsigned int uint8_t __attribute__((__mode__(__QI__)));
typedef signed int int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int uint16_t __attribute__ ((__mode__ (__HI__)));
typedef signed int int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int uint32_t __attribute__ ((__mode__ (__SI__)));

typedef signed int int64_t __attribute__((__mode__(__DI__)));
typedef unsigned int uint64_t __attribute__((__mode__(__DI__)));
# 146 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\stdint.h" 3 4
typedef int16_t intptr_t;




typedef uint16_t uintptr_t;
# 163 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\stdint.h" 3 4
typedef int8_t int_least8_t;




typedef uint8_t uint_least8_t;




typedef int16_t int_least16_t;




typedef uint16_t uint_least16_t;




typedef int32_t int_least32_t;




typedef uint32_t uint_least32_t;







typedef int64_t int_least64_t;






typedef uint64_t uint_least64_t;
# 217 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\stdint.h" 3 4
typedef int8_t int_fast8_t;




typedef uint8_t uint_fast8_t;




typedef int16_t int_fast16_t;




typedef uint16_t uint_fast16_t;




typedef int32_t int_fast32_t;




typedef uint32_t uint_fast32_t;







typedef int64_t int_fast64_t;






typedef uint64_t uint_fast64_t;
# 277 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\stdint.h" 3 4
typedef int64_t intmax_t;




typedef uint64_t uintmax_t;
# 10 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\lib\\gcc\\avr\\5.4.0\\include\\stdint.h" 2 3 4
# 38 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\inttypes.h" 2 3
# 77 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\inttypes.h" 3
typedef int32_t int_farptr_t;



typedef uint32_t uint_farptr_t;
# 127 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\sfr_defs.h" 2 3
# 100 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\io.h" 2 3
# 246 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\io.h" 3
# 1 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\iom32a.h" 1 3
# 247 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\io.h" 2 3
# 639 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\io.h" 3
# 1 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\portpins.h" 1 3
# 640 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\io.h" 2 3

# 1 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\common.h" 1 3
# 642 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\io.h" 2 3

# 1 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\version.h" 1 3
# 644 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\io.h" 2 3






# 1 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\fuse.h" 1 3
# 248 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\fuse.h" 3
typedef struct
{
    unsigned char low;
    unsigned char high;
} __fuse_t;
# 651 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\io.h" 2 3


# 1 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\lock.h" 1 3
# 654 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\io.h" 2 3
# 5 "lib\\ServoMotor\\src\\ServoMotor.h" 2
# 33 "lib\\ServoMotor\\src\\ServoMotor.h"

# 33 "lib\\ServoMotor\\src\\ServoMotor.h"
enum ServomotorTimer {
# 46 "lib\\ServoMotor\\src\\ServoMotor.h"
    SERVOMOTOR_TIMER_COUNT
};



class ServoMotorClass
{
public:







    uint8_t attach(volatile uint8_t *port, uint8_t pin);
# 72 "lib\\ServoMotor\\src\\ServoMotor.h"
    uint8_t attach(volatile uint8_t *port, uint8_t pin, uint16_t min, uint16_t max);






    void detach(uint8_t index);







    uint16_t getMIN(uint8_t index);







    void setMIN(uint8_t index, uint16_t value);







    uint16_t getMAX(uint8_t index);







    void setMAX(uint8_t index, uint16_t value);







    uint16_t getAngle(uint8_t index);







    void setAngle(uint8_t index, uint16_t value);







    uint16_t getMicroseconds(uint8_t index);







    void setMicroseconds(uint8_t index, uint16_t value);
# 152 "lib\\ServoMotor\\src\\ServoMotor.h"
    void update(ServomotorTimer timer, volatile uint16_t *TCNTn, volatile uint16_t *OCRnA);
};

extern ServoMotorClass ServoMotor;
# 2 "lib\\ServoMotor\\src\\ServoMotor.cpp" 2

# 1 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\util\\atomic.h" 1 3
# 38 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\util\\atomic.h" 3
# 1 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\avr\\interrupt.h" 1 3
# 39 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\util\\atomic.h" 2 3




# 42 "c:\\users\\master\\.platformio\\packages\\toolchain-atmelavr\\avr\\include\\util\\atomic.h" 3
static __inline__ uint8_t __iSeiRetVal(void)
{
    __asm__ __volatile__ ("sei" ::: "memory");
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    __asm__ __volatile__ ("cli" ::: "memory");
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    __asm__ __volatile__ ("sei" ::: "memory");
    __asm__ volatile ("" ::: "memory");
    (void)__s;
}

static __inline__ void __iCliParam(const uint8_t *__s)
{
    __asm__ __volatile__ ("cli" ::: "memory");
    __asm__ volatile ("" ::: "memory");
    (void)__s;
}

static __inline__ void __iRestore(const uint8_t *__s)
{
    (*(volatile uint8_t *)((0x3F) + 0x20)) = *__s;
    __asm__ volatile ("" ::: "memory");
}
# 4 "lib\\ServoMotor\\src\\ServoMotor.cpp" 2
# 12 "lib\\ServoMotor\\src\\ServoMotor.cpp"

# 12 "lib\\ServoMotor\\src\\ServoMotor.cpp"
typedef struct {
    uint8_t number: 3;
    uint8_t attached: 1;
} pin_t;

typedef struct {
    volatile uint8_t *port;
    pin_t pin;
    uint16_t ticks;
    uint16_t min;
    uint16_t max;
} servo_t;

static volatile uint8_t count = 0;
static volatile servo_t servos[(10 * SERVOMOTOR_TIMER_COUNT)];
static volatile int8_t channels[SERVOMOTOR_TIMER_COUNT];

long map(long x, long in_min, long in_max, long out_min, long out_max) {
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

uint8_t ServoMotorClass::attach(volatile uint8_t *port, uint8_t pin) {
    return this->attach(port, pin, 544, 2400);
}

uint8_t ServoMotorClass::attach(volatile uint8_t *port, uint8_t pin, uint16_t min, uint16_t max) {
    if (count < (10 * SERVOMOTOR_TIMER_COUNT)) {
        servos[count].port = port;

        servos[count].pin.number = pin;
        servos[count].pin.attached = 1;

        servos[count].min = min;
        servos[count].max = max;

        return count++;
    }

    return 255;
}

void ServoMotorClass::detach(uint8_t index) {
    if (index < count) {
        servos[index].pin.attached = 0;
    }
}

uint16_t ServoMotorClass::getMIN(uint8_t index) {
    if (index < count) {
        return servos[index].min;
    }

    return 0;
}

void ServoMotorClass::setMIN(uint8_t index, uint16_t value) {
    if (index < count) {
        servos[index].min = value;
    }
}

uint16_t ServoMotorClass::getMAX(uint8_t index) {
    if (index < count) {
        return servos[index].max;
    }

    return 0;
}

void ServoMotorClass::setMAX(uint8_t index, uint16_t value) {
    if (index < count) {
        servos[index].max = value;
    }
}

uint16_t ServoMotorClass::getAngle(uint8_t index) {
    if (index < count) {
        return (uint16_t) map(this->getMicroseconds(index), servos[index].min, servos[index].max, 0, 180);
    }

    return 0;
}

void ServoMotorClass::setAngle(uint8_t index, uint16_t value) {
    if (index < count) {
        this->setMicroseconds(index, (uint16_t) map(value, 0, 180, servos[index].min, servos[index].max));
    }
}

uint16_t ServoMotorClass::getMicroseconds(uint8_t index) {
    if (index < count) {
        return ((uint16_t) (servos[index].ticks / (4000000L / 1000000L)));
    } else {
        return 0;
    }
}

void ServoMotorClass::setMicroseconds(uint8_t index, uint16_t value) {
    if (index < count) {
        uint16_t ticks = ((uint16_t) (value * (4000000L / 1000000L)));

        
# 113 "lib\\ServoMotor\\src\\ServoMotor.cpp" 3
       for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)((0x3F) + 0x20)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 113 "lib\\ServoMotor\\src\\ServoMotor.cpp"
                                          {
            servos[index].ticks = ticks;
        }
    }
}

void ServoMotorClass::update(ServomotorTimer timer, volatile uint16_t *TCNTn, volatile uint16_t *OCRnA) {
    uint8_t index;

    if (channels[timer] < 0) {
        *TCNTn = 0;
    } else {
        index = (timer * 10) + channels[timer];

        if (index < count && servos[index].pin.attached) {
            *(servos[index].port) &= ~
# 128 "lib\\ServoMotor\\src\\ServoMotor.cpp" 3
                                     (1 << (
# 128 "lib\\ServoMotor\\src\\ServoMotor.cpp"
                                     servos[index].pin.number
# 128 "lib\\ServoMotor\\src\\ServoMotor.cpp" 3
                                     ))
# 128 "lib\\ServoMotor\\src\\ServoMotor.cpp"
                                                                  ;
        }
    }

    channels[timer]++;

    index = (timer * 10) + channels[timer];

    if (index < count && channels[timer] < 10) {
        *OCRnA = *TCNTn + servos[index].ticks;

        if (servos[index].pin.attached) {
            *(servos[index].port) |= 
# 140 "lib\\ServoMotor\\src\\ServoMotor.cpp" 3
                                    (1 << (
# 140 "lib\\ServoMotor\\src\\ServoMotor.cpp"
                                    servos[index].pin.number
# 140 "lib\\ServoMotor\\src\\ServoMotor.cpp" 3
                                    ))
# 140 "lib\\ServoMotor\\src\\ServoMotor.cpp"
                                                                 ;
        }
    } else {
        if (*TCNTn + 4 < ((uint16_t) (20000U * (4000000L / 1000000L)))) {
            *OCRnA = (uint16_t) ((uint16_t) (20000U * (4000000L / 1000000L)));
        } else {
            *OCRnA = *TCNTn + 4;
        }

        channels[timer] = -1;
    }
}

ServoMotorClass ServoMotor;
